The process followed by your team (make use of your essay if you are taking CS429) - (5 points)

Make sure to address the issues of iterative development, refactoring, testing and collaborative development (even if you are not using XP, you have to address these issues in your documentation).
\\

In the software development world, every project ultimately descends into chaos. Teams proactively battle against this entropy using formal software development methods. These methods can slow a projects descent, but they can, when used effectively, stall the descent entirely. One method that we learned and applied last semester in Software Engineering was Extreme Programming. Extreme Programming is a branch under Agile Software Development methodology and derives many of its practices from Agile Software Development including fast iteration cycles, use cases, and user stories; but, Extreme Programming differs from a typical Agile Software Development methodology through pair programming and complete unit testing. 

While my group last semester followed many of the practices of Extreme Programming, we did not adhere as strictly to pair programming. Why did the students in my group not desire pair programming, especially when I received multiple second-person accounts of groups that flawlessly utilized pair programming? Could group dynamic, individual skill, an unnecessary byproduct of our interspersed and erratic location on campus at any given time, or something else determine pair programming’s necessity and success? I believe that all of the aforementioned concerns contribute in peer hesitation to adopt and consistently practice pair programming. Some group atmospheres do not support or encourage their members to admit unfamiliarity or inexperience. Other individuals feel their skill does not necessitate someone else watching over their shoulder as they crank out clean code–line by line. And the sheer size and scatterness of the campus make it difficult for students to easily coordinate a place and time for pair programming. Because of the reality of resistance to pair programming, my group this semester has adopted it on an as-needed basis. We hope that this compromise will let skilled individuals maintain their efficiency while also helping the bottom line–those that may not be experts in the technology.

To improve team efficiency and facilitate grading, the instructors frequently require students to use Subversion: a program (more accurately “a lifestyle choice”) that helps software developers maintain and track all changes to, or version, a code repository–similar to what I’m doing manually for this essay. My group this semester hopes to improve efficiency adjustments to our project’s software development method by versioning our code with Git instead of Subversion. The biggest difference between Git and Subversion is how collaboration is organized. Subversion uses centralized remote repositories, which means that each collaborator syncs every change with a single master repository over the Internet. Git, on the other hand, uses decentralized repositories. In decentralized repositories, there is no single master repository and each collaborator’s local repository is autonomous. Because each local repository is autonomous, collaborators can reliably commit changes to their local repository even without an Internet connection. These changes can then be, when an Internet connection becomes available, pushed and pulled to and from other collaborators. This workflow makes Git’s reliability far superior to Subversion. Both Subversion and Git let collaborators create branches to pivot development for a specific feature, but Git further augments collaboration through a different feature: repository forks. When a collaborator forks a repository, they create an isolated copy of the original repository. In this new isolated repository, collaborators can create, delete, and commit changes to branches without worrying about conflicting with another collaborator. In case something goes awry, projects using Git commonly designate a stable branch on the main repository to guarantee a safe point to revert. For a group that wants to maximize efficiency, Git offers our project unparalleled autonomy, reliability, and safety.

While each collaborator using Git has a local copy of the main repository, many projects backup their repository to a remote service, such as Github, and designate their repository on Github as their main repository. Don’t be fooled–Github is more than just a service to host a remote Git repository; its website provides many tools to enhance efficiency.  One of these tools is the pull request: a proven, efficient, and convenient practice to submitting, review, and merge collections of changes. Pull requests are similar to formal code reviews, a process software development teams use to ensure code quality in incoming changes. Prior to completing a feature, the submitter submits their changes for a formal code review where they receive critique and feedback from other developers. Often a feature must go through many iterations in this stage before becoming “production ready.” While Github doesn’t natively facilitate formal code reviews, my group is self-imposing a rule that each pull request must be reviewed and approved by two other team members before merging. Reviewers can use Github’s web interface to review and comment on the pull request, its files, and even individual lines of code. 

But before we can even write a line of code, we need to know what features we want and when we want them. To solve this problem, we create user stories and assign each story a story point value. We hope to relieve some of the stress and inherent instability with assigning a fixed man-hour value while still providing an accurate estimate to facilitate the planning and management of iterations. Through user stories, we hope to be able to accurately portray the needs of the users while also providing realistic time estimates to help us pace ourselves so that we may finish the project within the deadlines.
